{
  "docs": [
    {
      "content": "*Madlib* is a functional language which is a combination of [JavaScript](https://www.javascript.com) and [Haskell](https://www.haskell.org/). It is similar in nature to [PureScript](https://www.purescript.org/), [ReasonML](https://reasonml.github.io) and [Elm](https://elm-lang.org/).\n\nIt compiles to both JavaScript and native binary executables. It is designed for the web and can be used for client and server applications as well as scripting.\n\nIts main goal is to enable users to write robust, reliable code that is expressive and easily tested. It uses an expressive and terse syntax that uses tacit (point-free) notation and `pipe` composition to combine functions in an easy and idiomatic way.\n\nHere's an example which facilitates displaying user files after reading them from disk, in parallel:\n\n```madlib\nimport type { Wish } from \"Wish\"\n\nimport Wish from \"Wish\"\nimport List from \"List\"\nimport File from \"File\"\nimport IO from \"IO\"\n\ntype User = User(String)\n\ngetInfoFilePath :: User -> String\ngetInfoFilePath = (user) => where(user) {\n  User(path) =>\n    path\n}\n\nreadUserInfos :: List User -> Wish {} (List String)\nreadUserInfos = (users) => pipe(\n  map(pipe(getInfoFilePath, File.read)),\n  Wish.parallel,\n  Wish.mapRej(() => ({}))\n)(users)\n\nWish.fulfill(\n  () => IO.errLine(\"Info files could not be read\"),\n  IO.log,\n  readUserInfos([User(\"./users/1.csv\"), User(\"./users/2.csv\")])\n)\n```\n\n",
      "depth": 0,
      "slug": "introduction",
      "title": "Introduction"
    },
    {
      "content": "Let's get started! The basics here will consist of:\n- installing `madlib` for Linux, macOS or Windows\n- compiling and running a simple \"Hello World\" application\n",
      "depth": 0,
      "slug": "getting-started",
      "title": "Getting started"
    },
    {
      "content": "Predominantly there are two ways you can install `madlib` today.\n\n## Via Node\n\nYou must first have [nodejs](https://nodejs.org/) installed. Then you can run:\n\nDepending on your preferences, either of these should be identical in behavior. \n- `yarn global add @madlib-lang/madlib`\n- `npm install @madlib-lang/madlib -g`\n\n## From Source Code\n\nYou can download the archive of a build for your target from the [releases page](https://github.com/madlib-lang/madlib/releases), unarchive it wherever appropriate ( `/opt` might be a good candidate on Linux / OSX ), and add the location to your PATH in your shell profile / preferences file. Currently 5 targets are supported:\n\n- linux `glibc`\n- linux `muslc`\n- osx `x64`\n- osx `arm64`\n- windows `x64`\n\n### Debugging\n\nOnce `madlib` has been installed, running `madlib --help` or `madlib -h` should show the following text:\n\n```shell\n################################################\n ____    __  ____   _____   ____    ____  ______\n|    \\  /  ||    \\  |    \\ |    |  |    ||      )\n|     \\/   ||     \\ |     \\|    |_ |    ||     <\n|__/\\__/|__||__|\\__\\|_____/|______||____||______)\n\n\n\nUsage: madlib COMMAND\n  madlib@0.18.5\n\nAvailable options:\n  -h,--help                Show this help text\n  -v,--version             Show version\n\nAvailable commands:\n  compile                  compile madlib code to js\n  run                      run a madlib module or package\n  test                     test tools\n  install                  install madlib packages\n  package                  packages a library\n  new                      create a new project\n  doc                      generate documentation\n  format                   format code\n  lsp                      start language server\n  config                   read informations about the current installation\n```\n",
      "depth": 1,
      "slug": "installation",
      "title": "Installation"
    },
    {
      "content": "Once you have [installed Madlib](/docs/installation), we'll look at how to use it to compile and run programs.\n\n## Setting up a new project\n\nMadlib comes with a minimal project generator, `madlib new`:\n```shell\nmadlib new PROJECT_NAME\n```\n\nIn a folder where you intend to store your Madlib projects, run the following commands:\n```shell\nmadlib new hello-world\ncd hello-world\n```\n\n## Editing source files\n\nIf you inspect the `/src` folder, you should see the following in `Main.mad`:\n\n```madlib\nimport IO from \"IO\"\n\nmain = () => {\n  IO.putLine(\"Hello world\")\n}\n```\n\n## What is happening, line by line?\n\n 1. `import IO from \"IO\"` - This imports the `IO` (Input / Output) module from Madlib's standard library.\n 2. `main = () => {` - This defines a function named `main` and opens a function body\n 3. `IO.putLine(\"Hello world\")` - This calls the `putLine` function with a `\"Hello world\"` string. Note that Madlib has a specific distinction between double-quotes, as used here, which indicate string literals, and single-quotes, like `'a'` which are used to specify characters / `char` types.\n\n## How can I run it?\n\nIn order to run `Main.mad`, execute this command:\n```shell\nmadlib run src/Main.mad\n```\n\n## How can I compile it?\n\nTo build it for use in `node`, you can use the following command:\n```shell\nmadlib compile --target node -i src/Main.mad -o build/hello-world.mjs\nnode ./build/hello-world.mjs\n```\n\nTo build a native binary instead, change the `target` flag to `llvm` (the final possible option is `web`)\n```\nmadlib compile --target llvm -i src/Main.mad -o build/hello-world\n./build/hello-world\n```\n",
      "depth": 1,
      "slug": "hello-world",
      "title": "Hello world"
    },
    {
      "content": "Once you've [installed](/docs/installation) `madlib` locally, you can run `madlib --help` to show similar documentation as you see on this page, but within the terminal. Additionally, you can run individual subcommands with the help flag, e.g. `madlib run --help` will bring up specific help text for `madlib run`\n\n### `madlib compile`\n\nCompile Madlib code\n\n#### Usage\n```\nmadlib compile (-i|--input INPUT) [-o|--output OUTPUT]\n               [-c|--config CONFIG] [-v|--verbose] [-d|--debug]\n               [-b|--bundle] [--optimize] [-t|--target TARGET]\n               [-w|--watch] [--coverage]\n```\n\n#### Available options:\n - `--help` (`-h`) - Show this help text in terminal\n - `--input INPUT` (`-i`) - What source to compile\n - `--output OUTPUT` (`-o`) - What path to compile to (default: \"./build/\")\n - `--config CONFIG` (`-c`) - What config to use (default: \"madlib.json\")\n - `--verbose` (`-v`) - Verbose output\n - `--debug` (`-d`) - Print AST info\n - `--bundle` (`-b`) - Bundle the compiled output in one file\n - `--optimize` - Optimize the output to generate smaller output files\n - `--target TARGET` (`-t`) - What target it should compile to, possible values are: \"browser\" or \"node\" or \"llvm\" (default: \"node\")\n - `--watch` (`-w`) - watch file changes for fast rebuilds\n - `--coverage` - compile with coverage enabled\n\n### `madlib run`\n\nExecute a Madlib program\n\n#### Usage\n```\nmadlib run PROGRAM [ARGS]\n```\n\n#### Available options\n - `--help` (`-h`) - Show this help text in terminal\n - `PROGRAM` - The package or module to run\n - `ARGS` - Arguments to pass to the program. **NB**: Note in order to pass flags you need to use the `--` delimiter\n\n### `madlib test`\n\nTest a Madlib program\n\n#### Usage\n```\nmadlib test [-i|--input INPUT] [-t|--target TARGET] [-w|--watch]\n            [--coverage]\n```\n\n#### Available options\n - `--help` (`-h`) - Show this help text in terminal\n - `--input INPUT` (`-i`) - What to test (default: \".\")\n - `--target TARGET` (`-t`) - What target it should compile to, possible values are: \"browser\", \"node\" or \"llvm\" (default: 'node')\n - `--watch` (`-w`) - watch file changes for fast rebuilds\n - `--coverage` - compile with coverage enabled\n\n### `madlib install`\n\nInstall a madlib package\n\n#### Usage\n```\nmadlib install PACKAGE\n```\n\n#### Available options\n - `PACKAGE` - This can be any valid module path, local or a git repository. See [modules](/docs/modules) for more.\n\n### `madlib package`\n\nPackage a Madlib library for publication\n\n#### Usage\n```\nmadlib package [-r|--rebuild]\n```\n\n#### Available options\n - `--help` (`-h`) - Show this help text in terminal\n - `--rebuild` (`-r`) - Rebuilds a package for an already built version and only bumps if there's a bigger change than the initial one\n\n### `madlib new`\n\nCreate a new Madlib project\n\n#### Usage\n```\nmadlib new FOLDER\n```\n\n#### Available options\n - `--help` (`-h`) - Show this help text in terminal\n - `FOLDER` - The folder to create for the new project\n\n### `madlib doc`\n\nAutomatically generate documentation based upon specially formatted strings! See the [autodoc](docs/autodoc) page for more.\n\n#### Usage\n```\nmadlib doc (-i|--input INPUT)\n```\n\n#### Available options:\n - `--help` (`-h`) - Show this help text in terminal\n - `--input INPUT` (`-i`) - What source(s) you want to generate documentation for\n\n### `madlib format`\n\nFormat a Madlib file automatically\n\n#### Usage\n```\nmadlib format [-i|--input INPUT] [--text CODE] [--fix] [--width WIDTH]\n```\n\n#### Available options:\n - `--help` (`-h`) - Show this help text\n - `--input INPUT` (`-i`) - What source(s) you want to format\n - `--text CODE` - Code you want to format\n - `--fix` - Applies the new formatting to the file\n - `--width WIDTH` - target width of document (default: 100)\n\n### `madlib lsp`\n\nStart the Madlib language server\n\n#### Usage\n```\nmadlib lsp\n```\n\n### `madlib config`\n\nRead information about the current installation\n\n#### Usage\n```\nmadlib config (COMMAND)\n```\n\n#### Available options:\n - `--help` (`-h`) - Show this help text\n\n#### Available commands:\n - `runtime-headers-path` - Show the path of the runtime headers\n - `runtime-lib-headers-path` - Show the path of headers from runtime libraries such as `libuv` or `libgc`\n - `install-dir` - Show the path to the local madlib installation\n",
      "depth": 1,
      "slug": "cli",
      "title": "Command Line Interface"
    },
    {
      "content": "Madlib attempts to build atop a few instances of prior art. It is designed to feel a bit like [Haskell](https://www.haskell.org/) and a bit like [JavaScript in a functional paradigm](https://ramdajs.com). Because it is designed with JavaScript in mind, there are low-level escape hatches (see [The Fence](/docs/the-fence) for one such affordance) so that it is easy to built within the existing JavaScript ecosystem, while adding the confidence and assurances that a statically compiled well-typed language affords.\n",
      "depth": 0,
      "slug": "language-features",
      "title": "Language features"
    },
    {
      "content": "## Literals\n\n### Integer\nInteger literals are whole numbers, possibly prefixed with `-`.\n\n#### Example\n```madlib\n1\n-1732\n```\n\n### Byte\nInteger literals are whole numbers between 0 and 255. \n\n#### Example\n```madlib\n(1 :: Byte)\n(255 :: Byte)\n(0 :: Byte)\n```\n**NB**: Note that if bytes are used in a context where the type is not coerced (as above), it might resolve as an integer due to how the Number instance default resolution works.\n\n### Float\nFloat literals are numbers with a decimal part, possibly prefixed with `-`.\n\n#### Example\n```madlib\n1.0\n-1732.05\n```\n\n### String\nStrings are characters within double quotes, or backticks for templated strings.\n\n#### Example\n```madlib\n\"hello world\"\n\nuserId = \"arnaud\"\n`https://domain.tld/users/&#36;{userId}`\n```\n\n### Character\nCharacter literals are single characters within single quotes, sometimes with a leading escape or backslash character.\n\n#### Example\n```madlib\n'a'\n'\\n'\n```\n\n#### Boolean\nBoolean literals are either `true` or `false`.\n\n#### Example\n```madlib\ntrue\nfalse\n```\n\n#### Unit\nThe **Unit** value can be used in type-specific constructs to represent an empty record.\n\n#### Example\n```madlib\n{}\n```\n**NB**: Unit only has one possible value `{}`\n\n## Lambdas\nIn Madlib, a function is simply a lambda, which may be assigned, passed around or used inline directly.\n\n#### Example\n```madlib\n(a, b) => a * b\nproduct = (a, b) => a * b\n```\n**NB**: All binary or greater (more than a single parameter) functions in Madlib are automatically curried.\n",
      "depth": 1,
      "slug": "expressions",
      "title": "Expressions"
    },
    {
      "content": "In Madlib there are two ways to provide type annotation. You can annotate a function assignment or an inline expression.\n\n### Function types\nFunction types are declared as follows:\n```madlib\nmyFunction :: a -> b -> c\n```\nThis indicates that there is a function named `myFunction` which takes two parameters of two different types, `a` and `b`. And it then returns a value of type `c`.\n\nIn a more concrete example, we could type a function that produces the sum of two integers like so:\n```\nsum :: Integer -> Integer -> Integer\n```\n\n### Type variables\n\n```madlib\nstringJoin :: String -> a -> String\n```\nMadlib types (also known as [Hindley-Milner types](https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system)) allow for completeness and type inference. (Unlike some languages you might have worked with, if the Madlib compiler says its wrong, you can trust that it's actually wrong.) These signatures allow for generic or indefinite types. They are represented with lowercased words, often even single lower cased characters. In the example above, we have an indefinite type `a` which can be anything.\n\n**NB**: All type variables can only instantiate with the same type. So in the function:\n```madlib\nidentity :: a -> a\nidentity = (x) => x\n```\nThe two `a` variables will always be the same concrete type when called. So `identity(3.3)` will always return a `Float` because it is called with a `Float`.\n\n#### Applying a type variable\nThe type `List` is \"incomplete\". In order for a `List` to be considered \"complete\" it must be applied with a concrete type. For example, a list of integers is defined as: `List Integer`. It is also possible to apply a type variable to it, so that we have a list of \"whatever\", e.g. `List a`\n\nFor a more concrete example, this is how `concat` (a function which combines two lists) from our standard library is typed:\n```madlib\nconcat :: List a -> List a -> List a\n```\n\n### Constraints\nAnalogous to Haskell type classes, Madlib has [interfaces](/docs/interfaces). For example, the standard library includes the `Inspect` interface, which has one method, `inspect`. If you wanted to have a function which uses it, perhaps something like:\n```madlib\npushAndLog = (item, list) => {\n  IO.putLine(inspect(item))\n  return [item, ...list]\n}\n```\nThe type of the above function would need to be the following:\n`pushAndLog :: a -> List a -> List a`\n\n**However!** Because `inspect` is called on the parameter `item` (type `a`), there's a missing constraint. The fact that we call a method on that item implies that the type `a` must be a type that implements `Inspect` (sometimes this is called a \"constraint\").\n\nTherefore, the correct type definition of `pushAndLog` is instead:\n```madlib\npushAndLog :: Inspect a => a -> List a -> List a\npushAndLog = (item, list) => {\n  IO.putLine(inspect(item))\n  return [item, ...list]\n}\n```\n\nA type annotation with constraints takes this form: `constraints => type` where `constraints` are in the shape of `Interface typeVar` or in the case of multiple constraints: `(Interface typeVar, OtherInterface otherVar)`. **NB**: Note the difference between the previously used type constructor `->` and this \"fat\" arrow used to indicate the constraint: `=>`\n\nAdditionally, be aware that a type variable can have multiple constraints, for example:\n```madlib\n// for reference IO.log has type:\n// Inspect a => a -> {}\n\nsumAndLog :: (Number a, Inspect a) => a -> a -> a\nsumAndLog = (a, b) => {\n  result = a + b\n  IO.log(result)\n  return result\n}\n```\nThis `sumAndLong` function can deal with integers, floating point numbers and bytes as a result of this constraint.\n\n### Function annotations\nWe can bind type definitions to concrete implementations with the `::` syntax:\n```madlib\nglue :: String -> String -> String\nglue = (a, b) => `&#36;{a}:&#36;{b}`\n```\n\nThis can also be applied to any assignment in the same manner:\n```madlib\nSERVER_URL :: String\nSERVER_URL = \"https://myserver.tld\"\n```\n\n### Expression annotations\nWe can bind type definitions to expressions inline like so:\n```madlib\n(expression :: type)\n```\n**NB**: Note, to avoid ambiguity, the parentheses when defining inline annotations are always necessary. This is designed to avoid this otherwise confusing case:\n~~`1 + 3 :: Float`~~\nAre we annotating `3` or `1 + 3`?\n\n## Built-in types\n\n### Integer\n### with JS backend\nIntegers are represented as JS number.\n\n#### with LLVM backend\nIntegers are represented as 64 bit signed numbers.\n\n#### Examples\n```madlib\n1\n-1\n2384933\n```\n\n### Float\n#### with JS backend\nFloats are represented as JS number.\n\n#### with LLVM backend\nFloats are encoded as IEEE 754.\n\n#### Examples\n```madlib\n1.3\n-1.3\n138.75\n```\n\n### Byte\n#### with JS backend\nBytes are represented as JS numbers.\n\n#### with LLVM backend\nBytes are 8-bit unsigned numbers.\n\n#### Examples\n```madlib\n(1 :: Byte)\n(255 :: Byte)\n```\n**NB:** Note that we have to use this expression annotation above in order to tell the compiler that we're not talking about Integers.\n\n### Number interface\nThe `Number` `interface` defines operations that can be used with numbers. It is implemented for the following types:\n- Integer\n- Float\n- Byte\n\nInfix methods of Number:\n- `+`\n- `-`\n- `*`\n- `>`\n- `<`\n- `>=`\n- `<=`\n\nThe default instance for Number is Integer. So if we're faced with an ambiguous instance, it resolves to Integer automatically except if a type annotation forces another type. This is why the inline annotations are needed for `Byte` expressions, above.\n\n### String\nA list of characters\n\n#### Examples\n```madlib\n\"Hello World\"\n`Hello World`\n```\n**NB:** Note that single-quote wrapped literals are parsed as Chars, not Strings!\n\n### Char\nThe constituent parts of Strings\n\n#### Examples\n```madlib\n'a'\n'\\n'\n```\n\n### Boolean\nA value that can be `true` or `false`\n\n#### Examples\n```madlib\ntrue\nfalse\n```\n\n### Unit\nThe unit type in Madlib is seen as the empty record.\nThe type and the value are represented by the same characters: `{}`.\n\n#### Examples\n```madlib\n{}\n```\n\n### List\n#### Examples\n```madlib\nnumbers = [4, 5, 6]\n[1, 2, 3, ...numbers] // [1, 2, 3, 4, 5, 6]\n[true, false, false]\n[{}, {}, {}, {}]\n```\nNote: Lists in Madlib must have unified types. If you wanted to have a list of disparate types, you'd need to have some intermediate wrapper value.\n\n### Dictionary\nDictionary is a key/value collection. A given key can only be present once in the collection. A key can be any type that implements the `Comparable` interface.\n\n#### Examples\n```madlib\n{{ \"key\": \"value\" }}\n```\n\n### Set\nSet is a collection similar to List, but all contained items are unique and ordered. Only values of types implementing Comparable can be part of a Set. There is no built-in syntax sugar for Set like there is for List or Dictionary. So you must use the constructor from the Set module of the standard library.\n\n#### Examples\n```madlib\nimport Set from \"Set\"\nSet.fromList([1, 2, 3])\n```\n\n### Tuples\nA tuple is a n-dimension grouping of values. It is analog to vector and can in fact be used to describe vectors or similar thing, but also to group things. As a matter of a fact, the Dictionary constructor `fromList` accepts a List of 2-tuples `#[key, value]`.\nThe type is represented like this: `#[type1, type2, ...typeN]`.\n\n#### Examples\nTuple syntax is as follows:\n```madlib\n#[1, 2, 3]\n#[\"a string\", true, {}, {{ \"key\": \"value\" }}]\n```\n\n### ByteArray\nA ByteArray is an array of Byte. It can be used to represent any byte sequence such as binary file content, image data, or pretty much anything as raw bytes. Like Set it does not have any special syntax but a few handy constructors and conversion functions such as: `fromList`, `toList`, `fromString`, `toString`.\n\n#### Examples\n```madlib\nimport ByteArray from \"ByteArray\"\n\nByteArray.fromList([50, 100, 150])\nByteArray.fromString(\"Hello\")\n```\n\n### Array\nArray offers a similar functionality as List but the internals are very much different. It is represented by arrays in JS and as a contiguous set of items in memory with the llvm backend. It is more efficient to push items at the end of an array or concatenate two arrays than lists, but it is more efficient to push items in front of a list. Other than that most functions for lists have their array equivalent such as `map`, `filter`, `reduce`.\n\n#### Examples\n```madlib\nimport Array from \"Array\"\n\nArray.fromList([1, 2, 3])\n```\n",
      "depth": 1,
      "slug": "types",
      "title": "Types"
    },
    {
      "content": "### Automatic Currying\n\nMadlib functions are automatically curried, so something such as:\n\n```madlib\nproduct :: Integer -> Integer -> Integer\nproduct = (a, b) => a * b\n```\n\nCan be partially applied and named, so you can have a morphism like `double`:\n\n```madlib\ndouble = sum(2)\n```\n\n### Placeholder Arguments\n\nBecause functions are automatically curried, we can use the `$` constant to introduce a \"placeholder\" argument:\n\n```madlib\nfraction :: Float -> Float -> Float\nfraction = (a, b) => a / b\n```\n\nThis function is a little hard-to-work-with as written, because the first parameter is the numerator. We can easily make this more palatable (without changing the original implementation) by using a placeholder parameter:\n\n```madlib\nhalf = fraction($, 2.0)\n```\nNow we have a function which only applies the `b` parameter and still expects the `a` parameter.\n\n### Pipe Composition\n\nMadlib provides the `pipe` composition function, which composes functions left-to-right:\n\n```madlib\npipe(\n  product(2),\n  product(10)\n)(40) // 800\n```\n\n### Composition Operator\n\nAdditionally, there is an equivalent infix operator, `|>` which works similarly:\n\n```madlib\n40 |> product(2) |> product(10)\n```\n",
      "depth": 1,
      "slug": "functions",
      "title": "Functions"
    },
    {
      "content": "Interfaces are a tool to extend type definitions generically. In order to articulate this, let's take a concrete example.\n\nFirstly, let's see how we can implement an inspection function for a tuple without interfaces. The function should take a 2-tuple as input, and return its String representation:\n\n```madlib\ninspectList :: #[a, b] -> String\ninspectList = (tuple) =>\n  where (tuple) {\n    #[a, b] =>\n      `#[&#36;{inspectA(a)}, &#36;{inspectB(b)}]`\n  }\n```\n\n`inspectA` and `inspectB` are not yet defined. We'd like to define them, but the issue is that these are indefinite types and could be any type. Madlib does not provide reflection tooling like Java, which might allow us to determine at runtime how a given value is structured. However, interfaces can provide an excellent means of overcoming this problem!\n\nLet's see how we can define the interface for our inspect problem:\n```madlib\ninterface Inspect a {\n  inspect :: a -> String\n}\n```\n\nSo with the above we are saying `Inspect` is implemented for a generic type `a`; we can call the interface method `inspect` with values of that type and return a String. This is also known as a _constraint_.\n\nNow we can use constraints within type annotations to declare that a type variable implements an interface. The fat arrow is used for this purpose:\n```madlib\nComparable a => a -> a -> Boolean\n```\nHere the type annotation tells us that the function must be called with values of a type (`a`) that implement the interface `Comparable` otherwise we'll get a compilation error which will yell that we're not meeting the defined constraint.\n\nComing back to our initial problem; we'd like to implement Inspect for the type `#[a, b]`. To do this, we can also constrain types in the head of an instance declaration:\n```madlib\ninstance (Inspect a, Inspect b) =>\n  Inspect #[a, b] {\n    inspect = (tuple) =>\n      where (tuple) {\n        #[a, b] =>\n          `#[&#36;{inspect(a)}, &#36;{inspect(b)}]`\n      }\n  }\n```\nNow with this instance constraint we need not care about how `inspect` will be performed for the types contained in the tuple. The `inspect` method will be dispatched to the underlying implementation, based on the concrete types the method is called with.\n\nSo, `inspect(#[1, true])` would respectively call the method from `Inspect Integer` and `Inspect Boolean`.\n",
      "depth": 1,
      "slug": "interfaces",
      "title": "Interfaces"
    },
    {"content": "", "depth": 1, "slug": "concurrency", "title": "Concurrency"},
    {
      "content": "Madlib comes with a set of predefined functions in the form of our Standard Library.\n\n(**NB**: Note that you can see it the raw library in code form [here](https://github.com/madlib-lang/madlib/tree/master/prelude/__internal__).)\n\nAdditionally, for an automatically generated version of the docs please go [here](https://madlib-lang.github.io/madlib).\n",
      "depth": 1,
      "slug": "stdlib",
      "title": "Standard library"
    },
    {
      "content": "### `IO.log`\n\n> `IO.log :: Inspect a => a -> {}`\n\nWrite a Madlib value to `stdout` / `console.log` (depending on environment)\n\n```madlib\nimport IO from \"IO\"\n\nmain = () => IO.log(\"Hey, cool!\")\n```\n\n### `IO.trace`\n\n> `IO.trace :: Inspect a => String -> a -> a`\n\nUseful pipe inspector utility, `trace` takes a String and anything and prints them, returning the latter\n\n```madlib\nimport IO from \"IO\"\n\nmain = () => {\n  pipe(\n    IO.trace(\"input\"),\n    (x) => x * 2,\n    IO.trace(\"output\")\n  )(2)\n}\n```\n",
      "depth": 2,
      "slug": "stdlib/IO",
      "title": "Standard Library: IO"
    },
    {
      "content": "### `String.toLower`\n\n> `String.toLower :: String -> String`\n\nConvert a string to lowercase\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.toLower,\n    IO.trace(\"output\")\n  )(\"Madlib Is Cool\")\n}\n```\n\n### `String.toUpper`\n\n> `String.toUpper :: String -> String`\n\nConvert a string to uppercase\n\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.toUpper,\n    IO.trace(\"output\")\n  )(\"Madlib Is Cool\")\n}\n```\n\n\n### `String.split`\n\n> `String.split :: String -> String -> List String`\n\nSplit a string by another search string\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.toLower,\n    String.split(\"i\"),\n    IO.trace(\"output\")\n  )(\"Madlib Is Cool\")\n}\n```\n\n### `String.join`\n\n> `String.join :: String -> List String -> String`\n\nJoin a string with a given delimiter string\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    map(String.toUpper),\n    String.join(\" > \"),\n    IO.trace(\"output\")\n  )([\"Madlib\", \"Is\", \"Cool\"])\n}\n```\n\n### `String.lines`\n\n> `String.lines :: String -> List String`\n\nSplit a string by newlines\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.lines,\n    IO.trace(\"output\")\n  )(`’Twas brillig, and the slithy toves\nDid gyre and gimble in the wabe:\nAll mimsy were the borogoves,\nAnd the mome raths outgrabe.`)\n}\n```\n\n### `String.unlines`\n\n> `String.unlines :: List String -> String`\n\nJoin a string by newlines\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.unlines,\n    IO.trace(\"output\")\n  )([\n    \"'Beware the Jabberwock, my son!\",\n    \"The jaws that bite, the claws that catch!\",\n    \"Beware the Jubjub bird, and shun\",\n    \"The frumious Bandersnatch!'\"\n  ])\n}\n```\n\n### `String.words`\n\n> `String.words :: String -> List String`\n\nSplit a string by spaces\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.words,\n    IO.trace(\"output\")\n  )(`He took his vorpal sword in hand;`)\n}\n```\n\n### `String.unwords`\n\n> `String.unwords :: List String -> String`\n\nJoin a string by spaces\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.unwords,\n    IO.trace(\"output\")\n  )([\n    \"Long\",\n    \"time\",\n    \"the\",\n    \"manxome\",\n    \"foe\",\n    \"he\",\n    \"sought—\"\n  ])\n}\n```\n\n### `String.toList`\n\n> `String.toList :: String -> List Char`\n\nConvert a String to a List Char\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.toList,\n    IO.trace(\"output\")\n  )(`So rested he by the Tumtum tree`)\n}\n```\n\n### `String.fromList`\n\n> `String.fromList :: List Char -> String`\n\nConvert a List Char to a String\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.fromList,\n    IO.trace(\"output\")\n  )(['A','n','d',' ','s','t',\n  'o','o','d',' ','a','w','h',\n  'i','l','e',' ','i','n',' ',\n  't','h','o','u','g','h','t','.'])\n}\n```\n\n### `String.slice`\n\n> `String.slice :: Integer -> Integer -> String -> String`\n\nCut part of a string out of another string\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.slice(0, 6),\n    IO.trace(\"output\")\n  )(\"Madlib Is Cool\")\n}\n```\n\n### `String.isEmpty`\n\n> `String.isEmpty :: String -> Boolean`\n\nTest whether a string is empty `\"\"`\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.isEmpty\n    IO.trace(\"output\")\n  )(\"\")\n}\n```\n\n### `String.drop`\n\n> `String.drop :: Integer -> String -> String`\n\nDrop a certain number of characters from the beginning of a string\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.drop(5),\n    IO.trace(\"output\")\n  )(\"And, as in uffish thought he stood,\")\n}\n```\n\n### `String.dropLast`\n\n> `String.dropLast :: Integer -> String -> String`\n\nDrop a certain number of characters from the end of a string\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.dropLast(7),\n    IO.trace(\"output\")\n  )(\"The Jabberwock, with eyes of flame,\")\n}\n```\n\n### `String.dropWhile`\n\n> `String.dropWhile :: (Char -> Boolean) -> String -> String`\n\nDrop characters based on a predicate function\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.dropWhile((c) => c != 'f'),\n    IO.trace(\"output\")\n  )(\"Came whiffling through the tulgey wood,\")\n}\n```\n\n### `String.take`\n\n> `String.take :: Integer -> String -> String`\n\nTake a certain number of characters from the beginning of the string\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.take(11),\n    IO.trace(\"output\")\n  )(\"And burbled as it came!\")\n}\n```\n\n### `String.takeLast`\n\n> `String.takeLast :: Integer -> String -> String`\n\nTake a certain number of characters from the end of a string\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.takeLast(23),\n    IO.trace(\"output\")\n  )(\"One, two! One, two! And through and through\")\n}\n```\n\n### `String.takeWhile`\n\n> `String.takeWhile :: (Char -> Boolean) -> String -> String`\n\nTake characters based on a predicate function\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.takeWhile((c) => c != 'b'),\n    IO.trace(\"output\")\n  )(\"The vorpal blade went snicker-snack!\")\n}\n```\n\n### `String.charAt`\n\n> `String.charAt :: Integer -> String -> Maybe Char`\n\nReturn the character at a given index. Since it may not exist, this returns a Maybe.\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.charAt(5),\n    IO.trace(\"output\")\n  )(`He left it dead, and with its head`)\n}\n```\n\n### `String.firstChar`\n\n> `String.firstChar :: String -> Maybe Char`\n\nReturn the first character in a string. Since it may not exist, this returns a Maybe.\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.firstChar,\n    IO.trace(\"output\")\n  )(`He went galumphing back.`)\n}\n```\n\n### `String.lastChar`\n\n> `String.lastChar :: String -> Maybe Char`\n\nReturn the last character in a string. Since it may not exist, this returns a Maybe.\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.lastChar,\n    IO.trace(\"output\")\n  )(`He went galumphing back.`)\n}\n```\n\n### `String.trim`\n\n> `String.trim :: String -> String`\n\nRemove whitespace characters at the beginning and end of a string\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.trim,\n    IO.trace(\"output\")\n  )(`  Come to my arms, my beamish boy!  `)\n}\n```\n\n### `String.trimStart`\n\n> `String.trimStart :: String -> String`\n\nRemove whitespace characters at the beginning of a string\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.trimStart,\n    IO.trace(\"output\")\n  )(`    O frabjous day! Callooh! Callay!”`)\n}\n```\n\n### `String.trimEnd`\n\n> `String.trimEnd :: String -> String`\n\nRemove whitespace characters at the end of a string\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.trimEnd,\n    IO.trace(\"output\")\n  )(`He chortled in his joy.     `)\n}\n```\n\n### `String.length`\n\n> `String.length :: String -> Integer`\n\nReturn the length of a string\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.length,\n    IO.trace(\"output\")\n  )(`’Twas brillig, and the slithy toves`)\n}\n```\n\n### `String.repeat`\n\n> `String.repeat :: Char -> Integer -> String`\n\nGiven a character and an integer `x`, return a string with that character repeated `x` times\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.repeat('x'),\n    IO.trace(\"output\")\n  )(3)\n}\n```\n\n### `String.match`\n\n> `String.match :: String -> String -> Boolean`\n\nMatch a string given a regular expression\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    map(String.match(\"[a-f]+\")),\n    IO.trace(\"output\")\n  )([\"deadbeef\", \"growl\"])\n}\n```\n\n### `String.replace`\n\n> `String.replace :: String -> String -> String -> String`\n\nReplace part of a string given a regular expression\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    map(String.replace(\"[a-f]+\", \"xxx\")),\n    IO.trace(\"output\")\n  )([\"deadbeef\", \"growl\"])\n}\n```\n\n### `String.pushChar`\n\n> `String.pushChar :: Char -> String -> String`\n\nInsert a char at the beginning of a string\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.pushChar('h'),\n    IO.trace(\"output\")\n  )(\"ey now\")\n}\n```\n\n### `String.appendChar`\n\n> `String.appendChar :: Char -> String -> String`\n\nAdd a char at the end of a string\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.appendChar('w'),\n    IO.trace(\"output\")\n  )(\"hey no\")\n}\n```\n\n### `String.reverse`\n\n> `String.reverse :: String -> String`\n\nReverse a string\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.reverse,\n    IO.trace(\"output\")\n  )(\"Madam I'm Adam\")\n}\n```\n\n### `String.includes`\n\n> `String.includes :: Char -> String -> Boolean`\n\nTest whether a string contains a given character\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    String.includes('x'),\n    IO.trace(\"output\")\n  )(\"Madam I'm Adam\")\n}\n```\n\n### `String.startsWith`\n\n> `String.startsWith :: String -> String -> Boolean`\n\nTest whether a string starts with a given string\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    map(String.startsWith(\"Mad\")),\n    IO.trace(\"output\")\n  )([\"Madam I'm Adam\", \"Sad am I mad. am\"])\n}\n```\n\n### `String.contains`\n\n> `String.contains :: String -> String -> Boolean`\n\nTest whether a string contains a given string\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    map(String.toLower),\n    map(String.contains(\"mad\")),\n    IO.trace(\"output\")\n  )([\"Madam I'm Adam\", \"Sad am I mad. am\"])\n}\n```\n\n### `String.endsWith`\n\n> `String.endsWith :: String -> String -> Boolean`\n\nTest whether a string ends with a given string\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\n\nmain = () => {\n  pipe(\n    map(String.endsWith(\"am\")),\n    IO.trace(\"output\")\n  )([\"Madam I'm Adam\", \"Sad am I mad. am\"])\n}\n```\n",
      "depth": 2,
      "slug": "stdlib/String",
      "title": "Standard Library: String"
    },
    {
      "content": "### `Function.complement`\n\n> `Function.complement :: (a -> Boolean) -> a -> Boolean`\n\nGiven a predicate function, produce a function which has the opposite predicate\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\nimport { complement } from \"Function\"\n\nmain = () => {\n  pipe(\n    map(complement(String.includes('z'))),\n    IO.trace(\"output\")\n  )([\"alpha\", \"zero\"])\n}\n```\n\n### `Function.always`\n\n> `Function.always :: a -> b -> a`\n\nAlways return the first supplied parameter no matter what\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\nimport { always } from \"Function\"\n\nmain = () => {\n  pipe(\n    always(\"no\"),\n    IO.trace(\"output\")\n  )([\"alpha\", \"zero\"])\n}\n```\n\n### `Function.identity`\n\n> `Function.identity :: a -> a`\n\nReturns what it is given\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\nimport { identity } from \"Function\"\n\nmain = () => {\n  pipe(\n    identity,\n    IO.trace(\"output\")\n  )([\"alpha\", \"zero\"])\n}\n```\n\n### `Function.equals`\n\n> `Function.equals :: Eq a => a -> a -> Boolean`\n\nEquality comparison as a function\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\nimport List from \"List\"\nimport { equals } from \"Function\"\n\nmain = () => {\n  pipe(\n    List.filter(equals(\"alpha\")),\n    IO.trace(\"output\")\n  )([\"alpha\", \"zero\"])\n}\n```\n\n### `Function.notEquals`\n\n> `Function.notEquals :: Eq a => a -> a -> Boolean`\n\nInequality comparison as a function\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\nimport List from \"List\"\nimport { notEquals } from \"Function\"\n\nmain = () => {\n  pipe(\n    List.filter(notEquals(\"alpha\")),\n    IO.trace(\"output\")\n  )([\"alpha\", \"zero\"])\n}\n```\n\n### `Function.ifElse`\n\n> `Function.ifElse :: (a -> Boolean) -> (a -> b) -> (a -> b) -> a -> b`\n\nTernary function which represents conditional logic by taking a predicate function and two transformer functions.\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\nimport { ifElse, identity } from \"Function\"\n\nmain = () => {\n  pipe(\n    ifElse(\n      String.startsWith(\"m\"),\n      (x) => x ++ x,\n      identity\n    ),\n    IO.trace(\"output\")\n  )(\"madlib\")\n}\n```\n\n### `Function.when`\n\n> `Function.when :: (a -> Boolean) -> (a -> a) -> a -> a`\n\n`ifElse` but with no else case\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\nimport { when } from \"Function\"\n\nmain = () => {\n  pipe(\n    when(\n      String.startsWith(\"m\"),\n      (x) => x ++ x,\n    ),\n    IO.trace(\"output\")\n  )(\"madlib\")\n}\n```\n\n### `Function.not`\n\n> `Function.not :: Boolean -> Boolean`\n\nGiven a boolean, produce the complement value (`true` becomes `false` and vice-versa)\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\nimport { when, not } from \"Function\"\n\nmain = () => {\n  pipe(\n    when(\n      pipe(String.startsWith(\"m\"), not),\n      (x) => x ++ x,\n    ),\n    IO.trace(\"output\")\n  )(\"madlib\")\n}\n```\n\n### `Function.noop`\n\n> `Function.noop :: a -> {}`\n\nGiven any value, return Unit `{}`\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\nimport { noop } from \"Function\"\n\nmain = () => {\n  pipe(\n    noop,\n    IO.trace(\"output\")\n  )(\"madlib\")\n}\n```\n\n### `Function.flip`\n\n> `Function.flip :: (a -> b -> c) -> b -> a -> c`\n\nSwaps the parameters of a binary function\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\nimport { flip } from \"Function\"\n\nprepend :: String -> String -> String\nprepend = (a, b) => a ++ b\n\nmain = () => {\n  pipe(\n    flip(prepend)(\"hooray\"),\n    IO.trace(\"output\")\n  )(\"madlib\")\n}\n```\n\n### `Function.any`\n\n> `Function.any :: (a -> Boolean) -> List a -> Boolean`\n\nGiven a predicate and a list, return true if the predicate matches anything\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\nimport { any } from \"Function\"\n\nprepend :: String -> String -> String\nprepend = (a, b) => a ++ b\n\nmain = () => {\n  pipe(\n    any(String.startsWith(\"mad\")),\n    IO.trace(\"output\")\n  )([\"madlib\", \"sadlib\"])\n}\n```\n\n### `Function.all`\n\n> `Function.all :: (a -> Boolean) -> List a -> Boolean`\n\nGiven a predicate and a list, return true if the predicate matches everything\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\nimport { all } from \"Function\"\n\nprepend :: String -> String -> String\nprepend = (a, b) => a ++ b\n\nmain = () => {\n  pipe(\n    all(String.startsWith(\"mad\")),\n    IO.trace(\"output\")\n  )([\"madlib\", \"sadlib\"])\n}\n```\n\n### `Function.either`\n\n> `Function.either :: (a -> Boolean) -> (a -> Boolean) -> a -> Boolean`\n\nFunctional \"or\": `either(() => true, () => false)`\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\nimport { any, either } from \"Function\"\n\nprepend :: String -> String -> String\nprepend = (a, b) => a ++ b\n\nmain = () => {\n  pipe(\n    any(either(\n      String.startsWith(\"bad\"),\n      String.startsWith(\"dad\")\n    )),\n    IO.trace(\"output\")\n  )([\"madlib\", \"sadlib\"])\n}\n```\n\n### `Function.both`\n\n> `Function.both :: (a -> Boolean) -> (a -> Boolean) -> a -> Boolean`\n\nFunctional \"and\": `both(() => true, () => false)`\n\n```madlib\nimport IO from \"IO\"\nimport String from \"String\"\nimport List from \"List\"\nimport { both } from \"Function\"\n\nprepend :: String -> String -> String\nprepend = (a, b) => a ++ b\n\nmain = () => {\n  pipe(\n    List.filter(\n      both(\n        String.startsWith(\"mad\"),\n        String.endsWith(\"lib\")\n      )\n    ),\n    IO.trace(\"output\")\n  )([\"madlib\", \"sadlib\", \"radlib\"])\n}\n```\n",
      "depth": 2,
      "slug": "stdlib/Function",
      "title": "Standard Library: Function"
    },
    {
      "content": "**The Fence** is our built-in escape hatch. While Madlib has a powerful type and inference system, \"fenced\" code allows you to drop down to any native JS construct. However, doing so will eschew any of the automatic type inference and instead treat code within the **The Fence** as opaque.\n\nIt has been a core feature of Madlib ideology from the very start of this project, as it can (if used *judiciously*) allow developers to build on top of existing JavaScript projects or allow for incremental migration to Madlib from JavaScript.\n\n## Danger\n\nUnder the hood Madlib uses the fenced code liberally, but with type annotations, which allows us to build well-typed code on top of raw JavaScript. When writing code in Madlib, to take advantage of our powerful type system you should generally only use **The Fence** when absolutely necessary.\n\n\n## Syntax\n\nIf you want to do something in Madlib which is not yet expressible in the current native Madlib syntax, you can wrap any valid JS expression with either the single-line fence pair (`#-` / `-#`), e.g.:\n```madlib\ncool = `Madlib can use raw JS if you _really_ need to.`\n#- console.log(cool) -#\n```\n\nOr a multi-line fence pair (`#- {` / `} -#`), e.g.\n\n```madlib\ndecode :: String -> Maybe String\nexport decode = (url) => #- {\n  try {\n    return Just(decodeURIComponent(url))\n  } catch(e) {\n    return Nothing\n  }\n} -#\n```\n\n## Utilities\n\nMadlib programs have good interoperability between Madlib and JavaScript (when targeting JS environments), but it is important to know of a few utilities if you need to use this feature:\n\n### `__listToJSArray__`\n\nConvert a Madlib List to a JS Array\n\n```madlib\na = [\"one\", \"two\", \"three\"]\n#- console.log(__listToJSArray__(a)) -#\n```\n\n### `__jsArrayToList__`\n\nConvert a JS Array to a Madlib List\n\n```madlib\nlist = #- {\n  const a = [\"one\", \"two\", \"three\"]\n  a.push(\"four\")\n  return __listToJSArray__(a)\n} -#\n```\n",
      "depth": 1,
      "slug": "the-fence",
      "title": "The Fence"
    },
    {
      "content": "## JS Backend\n\n### Functions\nAll madlib functions compiled to JS are curried and therefore have the form:\n```js\nlet functionName = param1 => param2 => body\n```\n\nFunctions with interface constraints take additional parameters, so for example a function with this signature:\n```madlib\ninsert :: Comparable k => k -> v -> Dictionary k v -> Dictionary k v\n```\nwould result in JS as:\n```js\nlet insert = comparableDict => k => v => dictionary => body\n```\n\n### Interface dictionaries\nAll defined dictionaries take the form:\n```js\nlet InterfaceName = {\n  InstanceTypeName: {\n    instanceMethodName: () => methodParam1 => methodParam2 => body\n  }\n}\n```\nTherefore in the above example, if one was to call insert from JS with Integer keys it should be called like this:\n```js\ninsert(Comparable.Integer)(3)(\"some value\")(someDictionary)\n```\n\n### ADTs\nAll ADTs take the same form once compiled, the type itself does not make it to the runtime and only\nconstructed values are left and have the form:\n```js\n{\n  __constructor: \"ConstructorName\",\n  __args: [arg1, arg2, ...] // <- the length matches the arity of the constructor\n}\n```\nTherefore, from this Madlib type:\n```madlib\ntype Maybe a\n  = Just(a)\n  | Nothing\n```\n\n`Just(5)` is represented as:\n```js\n{\n  __constructor: \"Just\",\n  __args: [5]\n}\n```\n\nAnd `Nothing` is represented as:\n```js\n{\n  __constructor: \"Nothing\",\n  __args: []\n}\n```\n\n\n## LLVM Backend\n",
      "depth": 0,
      "slug": "ffi",
      "title": "FFI"
    }
  ],
  "gettingStarted": {
    "intro": "*Madlib* is a functional language which is a combination of [JavaScript](https://www.javascript.com) and [Haskell](https://www.haskell.org/). It is similar in nature to [PureScript](https://www.purescript.org/), [ReasonML](https://reasonml.github.io) and [Elm](https://elm-lang.org/).\n\nIt compiles to both Javascript and native binary executables. It is primarily designed for the web and can be used for client and server applications as well as scripting.\n\nIts main goal is to enable users to write reliable code that can be easily tested and robust in a playful way. The playfulness and succint syntax is achieved via tacit ( aka pointfree ) notation and the `pipe` utility to compose functions. Here is a small example that displays some user files after reading them from disk, all in parallel:\n\n```madlib\nimport type { Wish } from \"Wish\"\n\nimport Wish from \"Wish\"\nimport List from \"List\"\nimport File from \"File\"\nimport IO from \"IO\"\n\ntype User = User(String)\n\ngetInfoFilePath :: User -> String\ngetInfoFilePath = (user) => where(user) {\n  User(path) =>\n    path\n}\n\nreadUserInfos :: List User -> Wish {} (List String)\nreadUserInfos = (users) => pipe(\n  map(pipe(getInfoFilePath, File.read)),\n  Wish.parallel,\n  Wish.mapRej(() => ({}))\n)(users)\n\nWish.fulfill(\n  () => IO.errLine(\"Info files could not be read\"),\n  IO.log,\n  readUserInfos([User(\"./users/1.csv\"), User(\"./users/2.csv\")])\n)\n```",
    "sections": []
  },
  "header": {
    "content": "> A language designed to make writing code a **delight**"
  },
  "home": [
    {
      "content": "Madlib is a pragmatic functional programming language which compiles to both native binary executables and JavaScript. It is similar in syntax to JavaScript (with a little bit of Haskell). Madlib embraces function composition, automatic currying, and monadic control structures.",
      "title": "A functional language with familiar syntax"
    },
    {
      "content": "Mutation is only possible in explicit safe places. Madlib is powered by the [Hindley-Milner type system](https://en.wikipedia.org/wiki/Hindley-Milner_type_system), which means that it has powerful type inference and doesn't need annotations in most cases. Madlib also allows for unsafe native JavaScript wrapped in \"the fence\", i.e. `#- Math.random() -#` which gives developers a potential escape hatch (but without the benefits of type inference)",
      "title": "Safety, Types and Pragmatism"
    },
    {
      "content": "\n\n * Auto-generated documentation — powered by the rich type system\n * VSCode language server - provides in-IDE feedback including real-time errors and type annotations for a faster development loop",
      "title": "Tooling"
    },
    {
      "content": "\n\n * UI View Library: build web apps in the browser\n * Server: simple servers inspired by `express`\n * [Parser library](https://madlib-lang.github.io/madparser): parse structured input with native Madlib\n * Markdown parser: parse markdown input with native Madlib",
      "title": "Libraries and Examples"
    }
  ],
  "nav": [
    {
      "changefreq": "weekly",
      "href": "/getting-started",
      "icon": "/assets/icon-star.svg",
      "priority": 0.69999999999999995559,
      "shortText": "Intro",
      "text": "Getting started"
    },
    {
      "changefreq": "weekly",
      "href": "/examples",
      "icon": "/assets/icon-star.svg",
      "priority": 0.69999999999999995559,
      "shortText": "Examples",
      "text": "Examples"
    },
    {
      "changefreq": "weekly",
      "href": "/projects",
      "icon": "/assets/icon-star.svg",
      "priority": 0.69999999999999995559,
      "shortText": "Projects",
      "text": "Projects"
    },
    {
      "changefreq": "weekly",
      "href": "/docs/introduction",
      "icon": "/assets/icon-star.svg",
      "priority": 0.69999999999999995559,
      "shortText": "Docs",
      "text": "Docs"
    },
    {
      "changefreq": "monthly",
      "href": "/playground",
      "icon": "/assets/icon-star.svg",
      "priority": 0.9000000000000000222,
      "shortText": "Playground",
      "text": "Playground"
    },
    {
      "changefreq": "monthly",
      "href": "/community",
      "icon": "/assets/icon-star.svg",
      "priority": 1,
      "shortText": "Community",
      "text": "Community"
    }
  ],
  "pages": [
    {
      "content": "Madlib ships with a number of core libraries which can do a lot for you out of the box. However, there are extant projects which extend it in a number of ways.\n\n## Libraries\n- [madlib-website](//github.com/madlib-lang/madlib-website) - This website, implemented on top of [MadUI](//github.com/madlib-lang/madui), [MadMarkdownRenderer](//github.com/madlib-lang/madmarkdown-renderer), [MadMarkdownParser](//github.com/madlib-lang/madmarkdown-parser), [Strata](//github.com/madlib-lang/strata) and [MadServer](//github.com/madlib-lang/madserver)\n- [MadUI](//github.com/madlib-lang/madui) - A lightweight DSL for rendering templates for the web \n- [Strata](//github.com/madlib-lang/strata) - A simple implementation of the [BEM Methodology](https://css-tricks.com/bem-101/)\n- [MadMarkdownParser](//github.com/madlib-lang/madmarkdown-parser) - A Madlib-based parser for Markdown\n- [MadMarkdownRenderer](//github.com/madlib-lang/madmarkdown-renderer) - A Madlib-based renderer for Markdown\n- [MadAMQP](//github.com/madlib-lang/madamqp) - A Madlib library to support AMQP\n- [MadJwt](//github.com/madlib-lang/madjwt) - A Madlib library for signing and decoding JSON Web Tokens\n- [MadServer](//github.com/madlib-lang/madserver) - A Madlib library for writing servers (based on [express](https://expressjs.com/))\n- [maddoc](//github.com/madlib-lang/maddoc) - A documentation site generator\n- [maddoc-cli](//github.com/madlib-lang/maddoc-cli) - CLI tooling for [maddoc](//github.com/madlib-lang/maddoc)\n\n",
      "depth": 0,
      "slug": "projects",
      "title": "Projects"
    },
    {
      "content": "## Quick Installation\n\nThe easiest way to install `madlib` is via `npm`:\n```sh\nnpm i @madlib-lang/madlib -g\n```\n\nYou are also welcome to [install from source](/docs/installation#from-source-code).\n\n## Making a new project\n\n```sh\nmadlib new <project-name>\ncd <project-name>\n```\n\n## Running your project\n\n```sh\nmadlib run src/Main.mad\n```\n\nYou can see additional commands and information by running `madlib --help` or viewing the [Command Line Interface](/docs/cli) page.\n\n## Development\n\n### Syntax\n\nYou can learn much more specific syntax on the [Language Features](/docs/language-features') page, but here is a quick example of some Madlib syntax you could drop in your new project's `src/Main.mad` file:\n\n```madlib\nimport IO from \"IO\"\n\ngreetWith :: String -> String -> String\ngreetWith = (greeting, x) => `&#36;{greeting} &#36;{x}`\n\ntype PetType\n  = PetDog\n  | PetCat\n  | PetHamster\n  | PetCthulu\n\ntype Creature\n  = Human(String)\n  | Alien(String)\n  | Pet(String, PetType)\n  | UnknownCreature\n\ngreetCreature :: String -> Creature -> String\ngreetCreature = (greeting, critter) => pipe(\n  where {\n    Human(name) => name\n    Alien(name) => name\n    Pet(name, _) => name\n    UnknownCreature => \"Unknown\"\n  },\n  greetWith(greeting)\n)(critter)\n\nmain = () => {\n  pipe(\n    greetCreature(\"Sup?\"),\n    IO.trace(\"Transmission!\")\n  )(Alien(\"Xyxyxyxyx\"))\n}\n```\n\nAs [mentioned above](#running-your-project) you can run this with `madlib run src/Main.mad` \n\nOnce you've familiarized yourself with the core syntax, one of the best ways to get to know the language is to work through the [examples](/examples) or learn more in our [documentation](/docs/introduction) page.\n",
      "depth": 0,
      "slug": "getting-started",
      "title": "Getting Started"
    },
    {
      "content": "Here's a listing of several examples you can use to better understand idiomatic Madlib syntax and methodology.\n\n*We're working on making this page have more clickable examples, please bear with us!*\n\n## Maybe\n\nHere are several variations of `Maybe` usage which are equivalent in behavior:\n\n```madlib\nimport type { Maybe } from \"Maybe\"\nimport { Just, Nothing } from \"Maybe\"\nimport IO from \"IO\"\n\nmain = () => {\n  x = Just({name: \"Brekk\"})\n  pipe(\n    where {\n      Just(z) => \"Hello \" ++ z.name ++ \"!\"\n      Nothing => \"Hey there\"\n    },\n    IO.trace(\"OUTPUT\")\n  )(x)\n}\n```\n\n```madlib\nimport type { Maybe } from \"Maybe\"\nimport { fromMaybe, Just } from \"Maybe\"\nimport IO from \"IO\"\n\nmain = () => {\n  x = Just({name: \"Brekk\"})\n  pipe(\n    map((z) => \"Hello \" ++ z.name),\n    fromMaybe(\"Hey there\"),\n    IO.trace(\"OUTPUT\")\n  )(x)\n}\n```\n\n```madlib\nimport type { Maybe } from \"Maybe\"\nimport { fromMaybe, Just } from \"Maybe\"\nimport IO from \"IO\"\n\nprepend :: String -> String -> String\nprepend = (pre, post) => pre ++ post\n\nmain = () => {\n  x = Just({name: \"Brekk\"})\n  pipe(\n    map(.name),\n    map(prepend(\"Hello \")),\n    fromMaybe(\"Hey there\"),\n    IO.trace(\"OUTPUT\")\n  )(x)\n}\n```\n",
      "depth": 0,
      "slug": "examples",
      "title": "Examples"
    },
    {
      "content": "You can use this web-based REPL to play with various examples here in the browser. See [examples](/examples) for more directed patterns and instruction.\n",
      "depth": 0,
      "slug": "playground",
      "title": "The Playground"
    },
    {
      "content": "Madlib is a small but vibrant community and we're looking for excited developers and more participants!\n\n## Code of Conduct\n\nMadlib strives to be an inclusive and collaborative space. You can see our [Code of Conduct here](https://github.com/madlib-lang/madlib/blob/master/CODE_OF_CONDUCT.md).\n\n## Troubleshooting\n\nAre you trying out Madlib but something isn't working? There are some resources on this site which may help you, but if you're stuck, please feel free to raise an issue in our [root repository](https://github.com/madlib-lang/madlib/issues) or [start a discussion](https://github.com/orgs/madlib-lang/discussions) if you are so inclined.\n\n## Contribute\n\nWe welcome contributions to [our codebases](https://github.com/madlib-lang), including improved documentation, translations (**NB**: *Coming soon to this site!*) or code. We have a Haskell-based language implementation [here](https://github.com/madlib-lang/madlib) and numerous other Madlib-based repositories visible [here](https://github.com/madlib-lang).\n\n### Feedback\n\nWe also welcome further discussion on Madlib and where we're planning to take it in the future, please [start a discussion](https://github.com/orgs/madlib-lang/discussions) if you are so inclined.\n\nYou're also welcome to seek us out on [Discord](https://discord.com/channels/530598289813536771/932841899914571787) and chat there.\n",
      "depth": 0,
      "slug": "community",
      "title": "Community"
    }
  ],
  "theme": {
    "breakpoints": [
      {"label": "xs", "point": "-Infinity", "vertical": false},
      {"label": "sm", "point": "22rem", "vertical": false},
      {"label": "md", "point": "48rem", "vertical": false},
      {"label": "lg", "point": "67rem", "vertical": false},
      {"label": "xl", "point": "70rem", "vertical": false}
    ],
    "colors": [
      {"color": "#000", "name": "black"},
      {"color": "#101020", "name": "offblack"},
      {"color": "#c8ff00", "name": "chartreuse"},
      {"color": "#0cf", "name": "cyan"},
      {"color": "#888", "name": "gray"},
      {"color": "#0f6", "name": "lime"},
      {"color": "#fc0068", "name": "magenta"},
      {"color": "#f60", "name": "orange"},
      {"color": "#a5ddfe", "name": "periwinkle"},
      {"color": "#60f", "name": "purple"},
      {"color": "#2d0024", "name": "offpurple"},
      {"color": "#fff", "name": "white"},
      {"color": "#ff0", "name": "yellow"}
    ]
  },
  "title": "Madlib"
}