import type { Element, Action } from "MadUI"
import type { State } from "@client/State"

import { Just, Nothing } from "Maybe"
import { Left, Right } from "Either"
import { mapRej } from "Wish"
import { multiply } from "Math"
import { identity } from "Function"
import String from "String"
import List from "List"
import Http from "Http"
import Dictionary from "Dictionary"

import { strata } from "Strata"
import {
  pre,
  code,
  button,
  div,
  className,
  innerHTML,
  textarea,
  spellcheck,
  onClick,
  onInput,
  InputEvent,
  style,
  text
} from "MadUI"

import { parse, toJsonString } from "@common/Playground"
import ServerInfo from "@client/ServerInfo"


LINE_HEIGHT :: Integer
LINE_HEIGHT = 25

stratum = strata("playground")


handleInput :: Action State
handleInput = (state, event) => pipe(
  where {
    InputEvent({ target: { value: v } }) =>
      v

    _ =>
      state.playground.code
  },
  (c) => of(() => ({
    ...state,
    playground: { ...state.playground, code: c },
  })),
  of
)(event)


handleRun :: Action State
handleRun = (state, _) => pipe(
  .playground,
  toJsonString,
  Http.post(ServerInfo.endpoint("/api/playgrounds")),
  map(
    pipe(
      .body,
      parse,
      where {
        Right(playground) =>
          (newState) => ({
            ...newState,
            playground: {
              ...newState.playground,
              output: playground.output,
            },
          })

        Left(_) =>
          identity
      }
    )
  ),
  mapRej((_, newState) => newState),
  of
)(state)


highlight :: List String -> String -> String -> String
highlight = (keywords, modifier, input) => pipe(
  String.join("|"),
  (asStr) => `(${asStr})`,
  String.replace($, `<span class="${stratum.em("syntax", [modifier])}">$1</span>`, input)
)(keywords)

renderLine :: String -> Element State
renderLine = (raw) => <div className={stratum.e("line")} innerHTML={raw} />

SYNTAX_LITERALS = ["true", "false", "[0-9]+(\\.[0-9]+)?", "\".*\""]
SYNTAX_KEYWORDS = [
  "if",
  "else",
  "where",
  "instance",
  "interface",
  "import",
  "export",
  "from",
  "type",
  "alias",
  "do",
  "pipe",
  "map",
  "chain",
  "return"
]

SYNTAX_SPECIAL = ["$"]
SYNTAX_OPERATORS = ["\+\+", "-", "/", "*"]

// this is close but not quite
// \b(?:[^"'])(IO|String|Either)(?:[^"'])\b

SYNTAX_TYPES = [
  "JsonValue",
  "AssertionError",
  "Either",
  "Parser",
  "Maybe",
  "IOError",
  "Location",
  "Parser",
  "Error",
  "Doc",
  "SimpleDoc",
  "Wish",
  "TransferEncoding",
  "Header",
  "Method",
  "ClientError",
  "Error",
  "DateTime",
  "LocalDateTime",
  "TimeUnit"
]
SYNTAX_CONSTRUCTORS = [
  "JsonString",
  "JsonInteger",
  "JsonFloat",
  "JsonBoolean",
  "JsonNull",
  "JsonObject",
  "JsonArray",
  "AssertionError",
  "Error",
  "ErrorWithMessage",
  "NotImplemented",
  "Left",
  "Right",
  "Parser",
  "Just",
  "Nothing",
  "ArgumentListToLong",
  "PermissionDenied",
  "AddressAlreadyInUse",
  "UnknownError",
  "Loc",
  "Parser",
  "Error",
  "EmptyDoc",
  "CharDoc",
  "TextDoc",
  "LineDoc",
  "CatDoc",
  "NestDoc",
  "UnionDoc",
  "ColumnDoc",
  "NestingDoc",
  "SEmpty",
  "SChar",
  "SText",
  "SLine",
  "Wish",
  "Chunked",
  "Compress",
  "Deflate",
  "Gzip",
  "Header",
  "CONNECT",
  "DELETE",
  "GET",
  "HEAD",
  "OPTIONS",
  "PATCH",
  "POST",
  "PUT",
  "TRACE",
  "AccessDenied",
  "AddressNotFound",
  "BadTransferEncoding",
  "BadUrl",
  "ConnectionFailed",
  "Http2FramingError",
  "IncompleteResponse",
  "InternalError",
  "InvalidSSLCertificate",
  "MalformedResponse",
  "NotSupported",
  "SSLConnectionFailed",
  "SSLEngineNotFound",
  "SSLInitializationFailed",
  "Timeout",
  "TooManyRedirects",
  "UnresolvedProxy",
  "UnsupportedProtocol",
  "BadResponse",
  "ClientError",
  "DateTime",
  "LocalDateTime",
  "Millisecond",
  "Second",
  "Minute",
  "Hour",
  "Day",
  "Month",
  "Year"
]

buildCodeElements :: String -> List (Element State)
buildCodeElements = pipe(
  highlight(SYNTAX_LITERALS, "literal"),
  highlight(SYNTAX_KEYWORDS, "keyword"),
  highlight(SYNTAX_CONSTRUCTORS, "constructor"),
  highlight(SYNTAX_TYPES, "type"),
  String.split("\n"),
  map(renderLine)
)


deriveHeight :: State -> String
deriveHeight = (state) => pipe(
  .playground,
  .code,
  String.split("\n"),
  List.length,
  multiply(LINE_HEIGHT),
  inspect,
  mconcat($, "px")
)(state)


displayPlaygroundOutput :: State -> Element State
displayPlaygroundOutput = (state) => where(state.playground.output) {
  Just({ stdout }) =>
    text(stdout)

  Nothing =>
    text("")
}


renderLines :: String -> List (Element State)
renderLines = (playgroundCode) => pipe(
  String.split("\n"),
  List.mapWithIndex((_, i) => inspect(i + 1)),
  map((line) => <div>{line}</div>)
)(playgroundCode)


Playground :: State -> Element State
export Playground = (state) => {
  output = displayPlaygroundOutput(state) 
  return <div className={stratum.e("")}>
    <div className={stratum.e("container")}>
      <div className={stratum.e("lines")}>
        {...renderLines(state.playground.code)}
      </div>
      <div className={stratum.em("editor", ["standalone"])}>
        <div className={stratum.e("content")} style={{{ "height": deriveHeight(state) }}}>
          <textarea
            spellcheck={false}
            className={stratum.e("input")}
            onInput={handleInput}
          >
            {state.playground.code}
          </textarea>
          <pre className={stratum.e("highlight")}>
            <code className={stratum.e("code")}>
              {...buildCodeElements(state.playground.code)}
            </code>
          </pre>
        </div>
      </div>
      <div className={
        stratum.em(
          "output",
          ["standalone", String.isEmpty(output) ? "empty" : "compiled"]
        )
      }>
          <button
            className={stratum.em("run-button", ["waiting", "standalone"])}
            onClick={handleRun}
          >
            Run
            <div className={
              stratum.e("run-indicator")
            }/>
          </button>
        <pre className={stratum.e("output-feed")}>
          <code className={stratum.e("output-code")}>
            {output}
          </code>
        </pre>
      </div>
    </div>
  </div>
}
