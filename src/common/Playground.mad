import type { Maybe } from "Maybe"
import type { Either } from "Either"
import type { JsonValue } from "JsonValue"
import type { Parser } from "JsonParser"
import JsonParser from "JsonParser"
import JsonPrinter from "JsonPrinter"
import { Just, Nothing } from "Maybe"


export alias Playground = {
  id :: Maybe String,
  code :: String,
  stdout :: Maybe String,
  stderr :: Maybe String,
}


setId :: String -> Playground -> Playground
export setId = (id, playground) => ({ ...playground, id: Just(id) })


getOptionalPropAs :: (Playground -> Maybe String) -> String -> Playground -> List #[String, JsonValue] -> List #[String, JsonValue]
getOptionalPropAs = (accessor, fieldName, playground, values) => where(accessor(playground)) {
  Just(value) =>
    [#[fieldName, JsonPrinter.string(value)], ...values]

  Nothing =>
   values
}


toJsonString :: Playground -> String
export toJsonString = (playground) => pipe(
  .code,
  (codeValue) => [#["code", JsonPrinter.string(codeValue)]],
  getOptionalPropAs(.id, "id", playground),
  getOptionalPropAs(.stdout, "stdout", playground),
  getOptionalPropAs(.stderr, "stderr", playground),
  JsonPrinter.object,
  JsonPrinter.printJson(80)
)(playground)


playgroundParser :: Parser Playground
playgroundParser = do {
  id <- JsonParser.maybe(JsonParser.field("id", JsonParser.string))
  code <- JsonParser.field("code", JsonParser.string)
  stdout <- JsonParser.maybe(JsonParser.field("stdout", JsonParser.string))
  stderr <- JsonParser.maybe(JsonParser.field("stderr", JsonParser.string))

  return of({ id, code, stdout, stderr })
}


parse :: String -> Either String Playground
export parse = (jsonString) => JsonParser.parse(playgroundParser, jsonString)
